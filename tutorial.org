#+title: Systemy cząsteczkowe w WebGL - tutorial
#+startup: hidestars

Using Org-Babel to write a tutorial :).



* Wstęp
  Witaj w tutorialu poświęconemu systemom cząsteczkowym w
  WebGL'u. Nauczysz się w nich zarówno podstaw tworzenia systemów
  cząsteczkowych (ang. particle systems), jak i renderowania ich w
  Internecie za pomocą technologii [[http://pl.wikipedia.org/wiki/WebGL][WebGL]]. Poradnik ten zakłada
  podstawową wiedzę programistyczną w zakresie języka JavaScript oraz
  biblioteki OpenGL dla dowolnego języka programowania.

  Tutorial ten powstał w ramach przedmiotu "Systemy OpenGL i Direct3D"
  na studiach II stopnia Informatyki Stosowanej na Akademii
  Górniczo-Hutniczej w Krakowie.

** WebGL
   WebGL jest rozszerzeniem języka JavaScript dającym dostęp do API
   dla grafiki 3D w przeglądarce. API to oparte jest na OpenGL ES
   2.0. WebGL jest silnie związany z HTML5, w szczególności z
   elementem =<canvas>=, wewnątrz którego można programowalnie rysować
   grafikę 2D i 3D.

   WebGL jest obecnie wspierany we wszystkich głównych przeglądarkach
   poza Internet Explorer'em, do którego jednak istnieją nieoficjalne
   rozszerzenia pozwalające tworzyć grafikę 3D.

   Więcej informacji oraz tutoriale i przykłady pracy z WebGL'em
   znajdziesz w materiałach zawartych na końcu niniejszego poradnika.

** Systemy cząsteczkowe

   Systemy cząsteczkowe to popularna metoda tworzenia efektów
   specjalnych w grafice komputerowej. Polega ona na symulowaniu wielu
   (dziesiątek, setek, tysięcy, czasem nawet milionów) malutkich
   cząstek, rysowanych jako punkt lub mały obrazek. Taki rój
   cząsteczek pozwala realistycznie rysować "rozmyte" zjawiska, takie
   jak dym, ogień, eksplozje, deszcz, gwiazdy czy galaktyki.

   http://upload.wikimedia.org/wikipedia/commons/2/28/Pi-explosion.jpg

   Aby móc skutecznie symulować tysiące cząsteczek, każda z nich musi
   być bardzo prosta. W praktyce, w grafice 3D, cząsteczki zwykle
   rysowane są jako oteksturowane, kolorowe kwadraty stale zwrócone w
   stronę ekranu ([[http://pl.wikipedia.org/wiki/Billboard_(grafika_komputerowa)][Billboarding]]). Cała złożoność kształtu cząsteczki
   tkwi w teksturze, a złożoność zachowania w algorytmie opisującym
   poruszanie się cząsteczek.

   W niniejszym tutorialu omówimy dokładnie budowę rozszerzalnych
   systemów cząsteczkowych, które mogą zostać wykorzystane w praktyce
   do gier i aplikacji 3D uruchamianych w przeglądarce.


* Przykłady
  Tymczasowa lista linków do przykładów.
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/skeleton.html
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/simple-particle.html
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/simple-emitter.html
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/advanced-emitter.html
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/advanced-emitter-jet-demo.html
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/advanced-emitter-smoke-demo.html
  https://dl.dropbox.com/u/216352/stosowana/OpenGL/advanced-emitter-snow-demo.html


* WebGL - szkielet

* Cząsteczki

#+name: SimpleParticleObject
#+begin_src javascript
    function Particle() {
        this.pos = vec3.create();
        this.vel = vec3.create();
        this.energy = 0.0;
        this.color = {r : 1.0, g : 1.0, b : 1.0};
    }

#+end_src

#+name: SimpleParticleDrawing
#+begin_src javascript

  function drawParticle(particle) {
  
      mvPushMatrix();
      //translate to proper location

      mat4.translate(mvMatrix, particle.pos);

      gl.uniform4f(shaderProgram.colorUniform, particle.color.r, particle.color.g, particle.color.b, particle.color.a);

      //draw
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, particleTexture);
      gl.uniform1i(shaderProgram.samplerUniform, 0);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexTextureCoordBuffer);
      gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, particleVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, particleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      
      setMatrixUniforms();
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, particleVertexPositionBuffer.numItems);

      mvPopMatrix();
  }
    
  
#+end_src

Blablabla, opis shaderów.

#+name: FragmentShader
#+begin_src html
<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;
 
    varying vec2 vTextureCoord;
 
    uniform sampler2D uSampler;
 
    uniform vec4 uColor;
 
    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        gl_FragColor = textureColor * uColor;
    }
</script>
#+end_src
 
#+name: VertexShader
#+begin_src html
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
 
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
 
    varying vec2 vTextureCoord;
 
    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>
#+end_src



* Emiter

#+name: SimpleEmitterObject
#+begin_src javascript
  function Emitter() {
      //state :)
      this.pos = vec3.create([0, 0, 0]);
      this.size = vec3.create([1.0, 1.0, 1.0]);
  
      this.startEnergy = 3.0;
      this.startSpeed = 2.0;
  
      this.startColor = {r : 1.0, g : 1.0, b : 1.0, a : 1.0};
      this.endColor = {r : 1.0, g : 1.0, b : 1.0, a : 0.0};
  
      this.particles = [];
      this.maxParticles = 1000;
      this.liveParticles = 0;
  
      this.particlesPerFrame = 10;
  
      var ip;
      for(ip = 0 ; ip < this.maxParticles ; ++ip) {
          this.particles[ip] = new Particle();
      }
  
      this.accumulator = 0.0;
      this.cooldown = 0.25;
  
      this.texture = null;
  
      //functions
      this.setTexture = function(name) {
          this.texture = gl.createTexture();
          this.texture.image = new Image();
          var fj = this; //hacking around callbacks
          this.texture.image.onload = function () {
              handleLoadedTexture(fj.texture)
          }
          
          this.texture.image.src = name;
      };
  
      this.update = function(time) {
          var i;
          //update current particles
          for(i = 0 ; i < this.liveParticles ; ++i) {
              this.particles[i].energy -= time;
  
              var path = vec3.create([0, 0, 0]);
              vec3.scale(this.particles[i].vel, time, path);
              vec3.add(this.particles[i].pos, path);
  
              this.particles[i].color = ColorLERP(this.startColor, this.endColor, (1.0 - this.particles[i].energy/this.startEnergy));
  
              if(this.particles[i].energy < 0) {
                  //swap dead with live particles;
                  var temp = this.particles[i];
                  this.particles[i] = this.particles[this.liveParticles-1];
                  this.particles[this.liveParticles - 1] = temp;
                  --this.liveParticles;
              }
          }
  
          //spawn new particles
          this.accumulator += time;
          while(this.accumulator > this.cooldown) {
              this.accumulator -= this.cooldown;
              for(i = 0 ; i < this.particlesPerFrame ; ++i) {
                  this.emitParticle();
              }
          }
  
      };
  
      this.draw = function() {
          var i;
          for(i = 0 ; i < this.liveParticles ; ++i) {
              this.drawParticle(this.particles[i]);
          }
      };
  
      //worker functions
      this.emitParticle = function() {
          if(this.liveParticles < this.maxParticles) {
              var i = this.liveParticles;
              this.particles[i].pos = vec3.create(this.pos);
              this.particles[i].vel = vec3.create([Math.random()-0.5, Math.random()-0.5, 0]); //TODO randomize
              vec3.normalize(this.particles[i].vel);
              vec3.scale(this.particles[i].vel, this.startSpeed);
              this.particles[i].energy = this.startEnergy;
              this.particles[i].color = CloneColor(this.startColor);
              ++this.liveParticles;
              
          }
      };
  
      this.drawParticle = function(particle) {
          mvPushMatrix();
          //translate to proper location
  
          mat4.translate(mvMatrix, particle.pos);
          mat4.scale(mvMatrix, this.size);
  
          gl.uniform4f(shaderProgram.colorUniform, particle.color.r, particle.color.g, particle.color.b, particle.color.a);
  
          //draw
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.uniform1i(shaderProgram.samplerUniform, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexTextureCoordBuffer);
          gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, particleVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexPositionBuffer);
          gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, particleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
          
          setMatrixUniforms();
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, particleVertexPositionBuffer.numItems);
  
          mvPopMatrix();
      };
  
  };
  
#+end_src

#+name: ColorUtils
#+begin_src javascript
  function ColorLERP(color1, color2, p) {
      var red = color1.r * (1-p) + color2.r*p;
      var green = color1.g * (1-p) + color2.g*p;
      var blue = color1.b * (1-p) + color2.b*p;
      var alpha = color1.a * (1-p) + color2.a*p;
      return { r : red, g : green, b : blue, a : alpha};
  }
  
  function CloneColor(color) {
      return { r : color.r, g : color.g, b : color.b, a : color.a };
  }
  
#+end_src


* Adv. emiter

#+name: AdvancedParticleObject
#+begin_src javascript
    function Particle() {
        this.pos = vec3.create();
        this.vel = vec3.create();

        this.energy = 0.0;
        this.initialEnergy = 0.0;

        this.startColor = {r : 1.0, g : 1.0, b : 1.0};
        this.endColor = {r : 1.0, g : 1.0, b : 1.0};

        this.startSize = 1.0;
        this.endSize = 1.0;

        this.startRotation = 0.0;

        this.mass = 1.0;
    }

#+end_src

FIXME move this somewhere else
#+name: Utils
#+begin_src javascript
  function LERP(a, b, p) {
      return a * (1-p) + b * p;
  }
#+end_src

#+name: AdvancedEmitterObject
#+begin_src javascript
  function Emitter() {
      
      //default data
      this.pos = vec3.create();
      this.startSize = 1.0;
      this.endSize = 1.0;
      
      this.startEnergy = 3.0;
      this.startSpeed = 2.0;
      
      this.startColor = {r : 1.0, g : 1.0, b : 1.0, a : 1.0};
      this.endColor = {r : 1.0, g : 1.0, b : 1.0, a : 0.0};
      
      this.particles = [];
      this.maxParticles = 1000;
      this.liveParticles = 0;
      
      this.particlesPerFrame = 10;
  
      this.particleMass = 1.0;
      this.startRotation = 0.0;
  
      var ip;
      for(ip = 0 ; ip < this.maxParticles ; ++ip) {
          this.particles[ip] = new Particle();
      }
      
      this.accumulator = 0.0;
      this.cooldown = 0.25;
    
      this.texture = null;
  
      this.useAdditiveBlending = true;
     
      //user-configurable particle initialization
      this.getParticlesPerFrame = function() {
          return this.particlesPerFrame;
      }
  
      this.getParticleStartPosition = function() {
          return vec3.create(this.pos);
      }
  
      this.getParticleStartEnergy = function() {
          return this.startEnergy;
      }
  
      this.getParticleStartVelocity = function() {
          return vec3.scale(vec3.normalize(vec3.create([Math.random() - 0.5, Math.random() - 0.5, 0])), this.startSpeed);
      }
  
      this.getParticleStartColor = function() {
          return CloneColor(this.startColor);
      }
  
      this.getParticleEndColor = function() {
          return CloneColor(this.endColor);
      }
  
      this.getParticleMass = function() {
          return this.particleMass;
      }
  
      this.getParticleStartSize = function() {
          return this.startSize;
      }
  
      this.getParticleEndSize = function() {
          return this.endSize;
      }
  
      this.getParticleStartRotation = function() {
          return this.startRotation;
      }
  
      //user-configurable particle update
      this.computeParticleColor = function(particle) {
          return ColorLERP(particle.startColor, particle.endColor, (1-particle.energy / particle.initialEnergy));
      }
  
      this.computeForces = function(particle) {
          return vec3.create([0, 0, 0]);
      }
  
      this.computeParticleSize = function(particle) {
          var scale = LERP(particle.startSize, particle.endSize, (1-particle.energy / particle.initialEnergy));
          return vec3.create([scale, scale, scale]);
      }
  
      this.computeParticleRotation = function(particle) {
          return particle.startRotation;
      }
  
      //algorithms
      this.setTexture = function(name) {
          this.texture = gl.createTexture();
          this.texture.image = new Image();
          var fj = this; //hacking around callbacks
          this.texture.image.onload = function () {
              handleLoadedTexture(fj.texture)
          }
          
          this.texture.image.src = name;
      };
  
      //FIXME from this point down code is copypasted and needs adaptation
      this.update = function(time) {
          var i;
          //update current particles
          for(i = 0 ; i < this.liveParticles ; ++i) {
              this.particles[i].energy -= time;
  
              var forces = this.computeForces(this.particles[i]);
              vec3.scale(forces, time);
              vec3.add(this.particles[i].vel, forces);
  
              var path = vec3.create([0, 0, 0]);
              vec3.scale(this.particles[i].vel, time/this.particles[i].mass, path);
              vec3.add(this.particles[i].pos, path);
  
              if(this.particles[i].energy < 0) {
                  //swap dead with live particles;
                  var temp = this.particles[i];
                  this.particles[i] = this.particles[this.liveParticles-1];
                  this.particles[this.liveParticles - 1] = temp;
                  --this.liveParticles;
              }
          }
  
          //spawn new particles
          this.accumulator += time;
          while(this.accumulator > this.cooldown) {
              this.accumulator -= this.cooldown;
              var ppf = this.getParticlesPerFrame();
              for(i = 0 ; i < ppf ; ++i) {
                  this.emitParticle();
              }
          }
  
      };
  
      this.draw = function() {
          if(this.useAdditiveBlending) {
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
          }
          else {
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
          }
  
          var i;
          for(i = 0 ; i < this.liveParticles ; ++i) {
              this.drawParticle(this.particles[i]);
          }
      };
  
      this.emitParticle = function() {
          if(this.liveParticles < this.maxParticles) {
              var i = this.liveParticles;
              this.particles[i].pos = this.getParticleStartPosition();
              this.particles[i].vel = this.getParticleStartVelocity();
  
              this.particles[i].energy = this.particles[i].initialEnergy = this.getParticleStartEnergy();
  
              this.particles[i].startColor = this.getParticleStartColor();
              this.particles[i].endColor = this.getParticleEndColor();
  
              this.particles[i].startSize = this.getParticleStartSize();
              this.particles[i].endSize = this.getParticleEndSize();
  
              this.particles[i].startRotation = this.getParticleStartRotation();
  
              this.particles[i].mass = this.getParticleMass();
  
              ++this.liveParticles;
              
          }
      };
  
      this.drawParticle = function(particle) {
          mvPushMatrix();
          //translate to proper location
  
          mat4.translate(mvMatrix, particle.pos);
          mat4.rotateZ(mvMatrix, this.computeParticleRotation(particle));
          mat4.scale(mvMatrix, this.computeParticleSize(particle));
  
          var color = this.computeParticleColor(particle);
          gl.uniform4f(shaderProgram.colorUniform, color.r, color.g, color.b, color.a);
  
          //draw
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.uniform1i(shaderProgram.samplerUniform, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexTextureCoordBuffer);
          gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, particleVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
          
          gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexPositionBuffer);
          gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, particleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
          
          setMatrixUniforms();
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, particleVertexPositionBuffer.numItems);
  
          mvPopMatrix();
      };
  
  }
  
    
#+end_src

* Tangled files   
** Skeleton
#+name: Skeleton
#+begin_src html :tangle skeleton.html :noweb tangle
  <html>
    <head>
      <title>Szkielet - WebGL</title>
      <<JSIncludes>>
      <<WebGL-Skeleton>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
    </body>
  </html>
#+end_src
*** Substructure
#+name: WebGL-Skeleton
#+begin_src html
  <script type="text/javascript">
    var gl;
    <<WebGL-Matrices-Skeleton>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Init-Skeleton>>
    <<WebGL-DrawScene-Skeleton>>
    <<WebGL-Tick-Skeleton>>
  </script>
#+end_src

#+name: WebGL-Init-Skeleton
#+begin_src javascript
    function webGLStart() {
        var canvas = document.getElementById("webgl_canvas");
        initGL(canvas);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
 
        tick();
    }
#+end_src

#+name: WebGL-Tick-Skeleton
#+begin_src javascript
    function tick() {
        requestAnimFrame(tick);
        drawScene();
    }
#+end_src

#+name: WebGL-DrawScene-Skeleton
#+begin_src javascript
 
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
 
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.enable(gl.BLEND);

        //tu kod rysujacy
     }

#+end_src

#+name: WebGL-Matrices-Skeleton
#+begin_src javascript
    var pMatrix = mat4.create();
#+end_src

** Simple particle

#+name: Example - simple particle
#+begin_src html :tangle simple-particle.html :noweb tangle
  <html>
    <head>
      <title>Pojedyncza cząsteczka</title>
      <<JSIncludes>>
      <<FragmentShader>>
      <<VertexShader>>
      <<WebGL-Simple-Particle>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
    </body>
  </html>
  
#+end_src

*** Substructure

#+name: WebGL-Simple-Particle
#+begin_src html
  <script type="text/javascript">
    <<WebGL-Matrix-Code>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Shaders-Init>>
    <<WebGL-Buffers-Init>>
    <<WebGL-Textures-Load>>
    <<WebGL-Texture-Init-Simple-Particle>>

    <<SimpleParticleObject>>
    <<SimpleParticleDrawing>>

    <<WebGL-World-Init-Simple-Particle>>
    <<WebGL-Init-Simple-Particle>>

    <<WebGL-DrawScene-Simple-Particle>>
    <<WebGL-Tick-Simple-Particle>>
  </script>
#+end_src

#+name: WebGL-Matrices-Simple-Particle
#+begin_src javascript
    var pMatrix = mat4.create();
#+end_src

#+name: WebGL-Init-Simple-Particle
#+begin_src javascript
    function webGLStart() {
        var canvas = document.getElementById("webgl_canvas");
        initGL(canvas);
        initShaders();
        initBuffers();
        initTexture();
        initWorld();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
 
        tick();
    }
#+end_src

#+name: WebGL-World-Init-Simple-Particle
#+begin_src javascript
    var testParticle;
    
    function initWorld() {
        testParticle = new Particle();
        testParticle.pos = vec3.create([1, 1, -5]);
    }
#+end_src

#+name: WebGL-Tick-Simple-Particle
#+begin_src javascript
    function tick() {
        requestAnimFrame(tick);
        drawScene();
    }
#+end_src

#+name: WebGL-DrawScene-Simple-Particle
#+begin_src javascript
 
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
 
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.enable(gl.BLEND);

        mat4.identity(mvMatrix);
        //tu kod rysujacy

        drawParticle(testParticle);
     }

#+end_src


#+name: WebGL-Texture-Init-Simple-Particle
#+begin_src javascript
    var particleTexture;
 
    function initTexture() {
        particleTexture = gl.createTexture();
        particleTexture.image = new Image();
        particleTexture.image.onload = function () {
            handleLoadedTexture(particleTexture)
        }
 
        particleTexture.image.src = "data/star.gif";
    }
#+end_src


** Simple emitter

#+name: Example - simple emitter
#+begin_src html :tangle simple-emitter.html :noweb tangle
  <html>
    <head>
      <title>Emiter cząstek</title>
      <<JSIncludes>>
      <<FragmentShader>>
      <<VertexShader>>

      <<WebGL-Simple-Emitter>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
    </body>
  </html>
  
#+end_src

*** Substructure

#+name: WebGL-Simple-Emitter
#+begin_src html
  <script type="text/javascript">
    <<WebGL-Matrix-Code>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Shaders-Init>>
    <<WebGL-Buffers-Init>>
    <<WebGL-Textures-Load>>
    <<WebGL-Texture-Init-Simple-Emitter>>

    <<ColorUtils>>

    <<SimpleParticleObject>>
    <<SimpleEmitterObject>>

    <<WebGL-World-Init-Advanced-Emitter>>
    <<WebGL-Init-Advanced-Emitter>>
    <<Update-World-Advanced-Emitter>>
    <<WebGL-DrawScene-Advanced-Emitter>>
    <<WebGL-Animate-VariableStep>>
    <<WebGL-Tick-Advanced-Emitter>>
  </script>
#+end_src

#+name: WebGL-Init-Simple-Emitter
#+begin_src javascript
    function webGLStart() {
        var canvas = document.getElementById("webgl_canvas");
        initGL(canvas);
        initShaders();
        initBuffers();
        initWorld();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
 
        tick();
    }
#+end_src


#+name: WebGL-World-Init-Simple-Emitter
#+begin_src javascript
  var testEmitter;
  var testEmitter2;
  
  function initWorld() {
      testEmitter = new Emitter();
      testEmitter.pos = vec3.create([1, 1, -8]);
      testEmitter.size = vec3.create([0.5, 0.5, 1.0]);
      testEmitter.setTexture("data/star.gif");
      testEmitter.startColor = { r : 1.0, g : 0.0, b : 1.0, a : 1.0};
      testEmitter.endColor = { r : 0.0, g : 1.0, b : 0.0, a : 0.0};
  
  
      testEmitter2 = new Emitter();
      testEmitter2.pos = vec3.create([-1, -1, -9]);
      testEmitter2.size = vec3.create([0.25, 0.25, 1.0]);
      testEmitter2.startEnergy = 5.0;
      testEmitter2.cooldown = 1.0;
      testEmitter2.startVelocity = vec3.create([1.0, 1.0, 0.0]);
      testEmitter2.setTexture("data/flower.png");
  }
  
#+end_src


#+name: WebGL-Tick-Simple-Emitter
#+begin_src javascript
    function tick() {
        requestAnimFrame(tick);
        animate();
        drawScene();
    }
#+end_src

#+name: WebGL-DrawScene-Simple-Emitter
#+begin_src javascript
 
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
 
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.enable(gl.BLEND);

        mat4.identity(mvMatrix);
        //tu kod rysujacy

        testEmitter.draw();
        testEmitter2.draw();
     }

#+end_src

#+name: Update-World-Simple-Emitter
#+begin_src javascript
  function UpdateWorld(dt) {
      testEmitter.update(dt);
      testEmitter2.update(dt);
  }
#+end_src



To wszystko idzie do przerycia; stanie się elementem emitera.
#+name: WebGL-Texture-Init-Simple-Emitter
#+begin_src javascript

#+end_src


** Advanced Emitter

#+name: Example - advanced emitter
#+begin_src html :tangle advanced-emitter.html :noweb tangle
  <html>
    <head>
      <title>Zaawansowany emiter cząstek</title>
      <<JSIncludes>>
      <<FragmentShader>>
      <<VertexShader>>

      <<WebGL-Advanced-Emitter>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
    </body>
  </html>
  
#+end_src


*** Substructure

#+name: WebGL-Advanced-Emitter
#+begin_src html
  <script type="text/javascript">
    <<WebGL-Matrix-Code>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Shaders-Init>>
    <<WebGL-Buffers-Init>>
    <<WebGL-Textures-Load>>
    <<WebGL-Texture-Init-Advanced-Emitter>>

    <<ColorUtils>>

    <<AdvancedParticleObject>>

    //FIXME!
    <<Utils>>
    <<AdvancedEmitterObject>>

    <<WebGL-World-Init-Advanced-Emitter>>
    <<WebGL-Init-Advanced-Emitter>>
    <<Update-World-Advanced-Emitter>>
    <<WebGL-DrawScene-Advanced-Emitter>>
    <<WebGL-Animate-VariableStep>>
    <<WebGL-Tick-Advanced-Emitter>>
  </script>
#+end_src


#+name: WebGL-Init-Advanced-Emitter
#+begin_src javascript
<<WebGL-Init-Simple-Emitter>>
#+end_src


#+name: WebGL-World-Init-Advanced-Emitter
#+begin_src javascript
  var testEmitter;
  var testEmitter2;
  
  function initWorld() {
      testEmitter = new Emitter();
      testEmitter.pos = vec3.create([1, 1, -8]);
      testEmitter.startSize = 0.5;
      testEmitter.endSize = 0.5;
      testEmitter.setTexture("data/star.gif");
      testEmitter.startColor = { r : 1.0, g : 0.0, b : 1.0, a : 1.0};
      testEmitter.endColor = { r : 0.0, g : 1.0, b : 0.0, a : 0.0};
  
  
      testEmitter2 = new Emitter();
      testEmitter2.pos = vec3.create([-1, -1, -9]);
      testEmitter2.startSize = 0.25;
      testEmitter2.endSize = 0.25;
      testEmitter2.startEnergy = 5.0;
      testEmitter2.cooldown = 1.0;
      testEmitter2.startVelocity = vec3.create([1.0, 1.0, 0.0]);
      testEmitter2.setTexture("data/flower.png");
  }
  
#+end_src

#+name: WebGL-Tick-Advanced-Emitter
#+begin_src javascript
<<WebGL-Tick-Simple-Emitter>>
#+end_src

#+name: WebGL-DrawScene-Advanced-Emitter
#+begin_src javascript
 
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
 
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.enable(gl.BLEND);

        mat4.identity(mvMatrix);
        //tu kod rysujacy

        testEmitter.draw();
        testEmitter2.draw();
     }

#+end_src

#+name: Update-World-Advanced-Emitter
#+begin_src javascript
  function UpdateWorld(dt) {
      testEmitter.update(dt);
      testEmitter2.update(dt);
  }
#+end_src

** Removing unused emitter for adv. demos

#+name: WebGL-DrawScene-Advanced-Emitter-Demos
#+begin_src javascript
 
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
 
        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
 
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
        gl.enable(gl.BLEND);

        mat4.identity(mvMatrix);
        //tu kod rysujacy

        testEmitter.draw();
     }

#+end_src

#+name: Update-World-Advanced-Emitter-Demos
#+begin_src javascript
  function UpdateWorld(dt) {
      testEmitter.update(dt);
  }
#+end_src


** Tangle for Adv. demos
#+name: JSIncludes-Tangle
#+begin_src javascript
  <<JSIncludes>>

  <!-- Tangle -->
  <script type="text/javascript" src="js/Tangle.js"></script>
    
  <!-- TangleKit (optional) -->
  <link rel="stylesheet" href="js/TangleKit/TangleKit.css" type="text/css">
  <script type="text/javascript" src="js/TangleKit/mootools.js"></script>
  <script type="text/javascript" src="js/TangleKit/sprintf.js"></script>
  <script type="text/javascript" src="js/TangleKit/BVTouchable.js"></script>
  <script type="text/javascript" src="js/TangleKit/TangleKit.js"></script>
    
#+end_src

#+name: Tangle-Code
#+begin_src javascript
  <script type="text/javascript">
      var tangle = null;
  
      var model = {
          initialize : function() {
              this.startR = testEmitter.startColor.r;
              this.startG = testEmitter.startColor.g;
              this.startB = testEmitter.startColor.b;
              this.startA = testEmitter.startColor.a;
  
              this.endR = testEmitter.endColor.r;
              this.endG = testEmitter.endColor.g;
              this.endB = testEmitter.endColor.b;
              this.endA = testEmitter.endColor.a;
  
              this.startEnergy = testEmitter.startEnergy;
              this.cooldown = testEmitter.cooldown;
              this.particlesPerFrame = testEmitter.particlesPerFrame;
              
              this.startSize = testEmitter.startSize;
              this.endSize = testEmitter.endSize;
  
              this.startX = testEmitter.pos.x;
              this.startY = testEmitter.pos.y;
              this.startZ = testEmitter.pos.z;
          },
  
          update : function() {
              testEmitter.startColor.r = this.startR;
              testEmitter.startColor.g = this.startG;
              testEmitter.startColor.b = this.startB;
              testEmitter.startColor.a = this.startA;
  
              testEmitter.endColor.r = this.endR;
              testEmitter.endColor.g = this.endG;
              testEmitter.endColor.b = this.endB;
              testEmitter.endColor.a = this.endA;
  
  
              testEmitter.startEnergy = this.startEnergy;
              testEmitter.cooldown = this.cooldown;
              testEmitter.particlesPerFrame = this.particlesPerFrame;
              
              testEmitter.startSize = this.startSize;
              testEmitter.endSize = this.endSize;
  
              testEmitter.pos.x = this.startX;
              testEmitter.pos.y = this.startY;
              testEmitter.pos.z = this.startZ;
  
          }
      };
  
  function startTangle() {
      tangle = new Tangle(document.getElementById("control-panel"), model);
  }
  </script>
#+end_src

#+name: Tangle-Panel
#+begin_src html
  <p id="control-panel">Pojedyncza cząsteczka startuje z kolorem: {
  r : <span class="TKAdjustableNumber" data-var="startR"></span>, g :
  <span class="TKAdjustableNumber" data-var="startG"></span>, b :
  <span class="TKAdjustableNumber" data-var="startB"></span>, a :
  <span class="TKAdjustableNumber" data-var="startA"></span> } i po
  <span class="TKAdjustableNumber" data-var="startEnergy"></span>
  sekundach kończy z z kolorem: { r : <span class="TKAdjustableNumber"
  data-var="endR"></span>, g : <span class="TKAdjustableNumber"
  data-var="endG"></span>, b : <span class="TKAdjustableNumber"
  data-var="endB"></span>, a : <span class="TKAdjustableNumber"
  data-var="endA"></span> }. Cząsteczki emitowane są co <span
  class="TKAdjustableNumber" data-var="cooldown"></span> sekund(y) po
  <span class="TKAdjustableNumber"
  data-var="particlesPerFrame"></span> na raz. Zmieniają też swój
  rozmiar od <span class="TKAdjustableNumber"
  data-var="startSize"></span> na początku do <span
  class="TKAdjustableNumber" data-var="endSize"></span> na
  końcu. Emiter znajduje się w punkcie: [<span
  class="TKAdjustableNumber" data-var="startX"></span>, <span
  class="TKAdjustableNumber" data-var="startY"></span>, <span
  class="TKAdjustableNumber" data-var="startZ"></span>].</p>
#+end_src

** Advanced Emitter - Jet Demo

#+name: Example - advanced emitter jet demo
#+begin_src html :tangle advanced-emitter-jet-demo.html :noweb tangle
  <html>
    <head>
      <title>Zaawansowany emiter cząstek - symulacja odrzutu</title>
      <<JSIncludes-Tangle>>
      <<FragmentShader>>
      <<VertexShader>>

      <<WebGL-Advanced-Emitter-Jet>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
      <<Tangle-Code>>
      <<Tangle-Panel>>
    </body>
  </html>
  
#+end_src

*** Substructure

#+name: WebGL-Advanced-Emitter-Jet
#+begin_src html
  <script type="text/javascript">
    <<WebGL-Matrix-Code>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Shaders-Init>>
    <<WebGL-Buffers-Init>>
    <<WebGL-Textures-Load>>
    <<WebGL-Texture-Init-Advanced-Emitter>>

    <<ColorUtils>>

    <<AdvancedParticleObject>>

    //FIXME!
    <<Utils>>
    <<AdvancedEmitterObject>>

    <<WebGL-World-Init-Advanced-Emitter-Jet>>
    <<WebGL-Init-Advanced-Emitter>>
    <<Update-World-Advanced-Emitter-Demos>>
    <<WebGL-DrawScene-Advanced-Emitter-Demos>>
    <<WebGL-Animate-VariableStep>>
    <<WebGL-Tick-Advanced-Emitter>>
  </script>
#+end_src

#+name: WebGL-World-Init-Advanced-Emitter-Jet
#+begin_src javascript
  var testEmitter;

  function initWorld() {
      testEmitter = new Emitter();
      testEmitter.pos = vec3.create([1, 1, -8]);
      testEmitter.startSize = 0.25;
      testEmitter.endSize = 0.05;
      testEmitter.setTexture("data/smoke.jpg");
      testEmitter.startColor = { r : 1, g : 69/255, b : 0.27, a : 0.5};
      testEmitter.endColor = { r : 0.7, g : 0.7, b : 0.7, a : 0.7};
      testEmitter.particlesPerFrame = 2;
      testEmitter.cooldown = 0.01;
  
      testEmitter.getParticleStartVelocity = function () {
          return vec3.create([-2, Math.random() - 0.5, 0]);
      };

      startTangle();
  }
  
#+end_src


** Advanced Emitter - Smoke Demo

#+name: Example - advanced emitter smoke demo
#+begin_src html :tangle advanced-emitter-smoke-demo.html :noweb tangle
  <html>
    <head>
      <title>Zaawansowany emiter cząstek - symulacja dymu</title>
      <<JSIncludes-Tangle>>
      <<FragmentShader>>
      <<VertexShader>>
  
      <<WebGL-Advanced-Emitter-Smoke>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
      <<Tangle-Code>>
      <<Tangle-Panel>>
    </body>
  </html>
  
#+end_src

*** Substructure

#+name: WebGL-Advanced-Emitter-Smoke
#+begin_src html
  <script type="text/javascript">
    <<WebGL-Matrix-Code>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Shaders-Init>>
    <<WebGL-Buffers-Init>>
    <<WebGL-Textures-Load>>
    <<WebGL-Texture-Init-Advanced-Emitter>>

    <<ColorUtils>>

    <<AdvancedParticleObject>>

    //FIXME!
    <<Utils>>
    <<AdvancedEmitterObject>>

    <<WebGL-World-Init-Advanced-Emitter-Smoke>>
    <<WebGL-Init-Advanced-Emitter>>
    <<Update-World-Advanced-Emitter-Demos>>
    <<WebGL-DrawScene-Advanced-Emitter-Demos>>
    <<WebGL-Animate-VariableStep>>
    <<WebGL-Tick-Advanced-Emitter>>
  </script>
#+end_src

#+name: WebGL-World-Init-Advanced-Emitter-Smoke
#+begin_src javascript
  var testEmitter;
  
  function initWorld() {
      testEmitter = new Emitter();
      testEmitter.pos = vec3.create([-1, -1, -8]);
      testEmitter.startSize = 0.1;
      testEmitter.endSize = 1;
      testEmitter.setTexture("data/smoke.jpg");
      testEmitter.startColor = { r : 0.2, g : 0.2, b : 0.2, a : 1 };
      testEmitter.endColor = { r : 0.0, g : 0.0, b : 0.0, a : 0.5 };

      testEmitter.cooldown = 0.03;
      testEmitter.particlesPerFrame = 1;
  
      
testEmitter.getParticleStartVelocity = function() { return vec3.create([1, Math.random()/2, 0]); };
      testEmitter.getParticleStartEnergy = function () { return this.startEnergy + Math.random(); };    
    }
  
#+end_src

** Advanced Emitter - Snow Demo

#+name: Example - advanced emitter snow demo
#+begin_src html :tangle advanced-emitter-snow-demo.html :noweb tangle
  <html>
    <head>
      <title>Zaawansowany emiter cząstek - symulacje fizyczne</title>
      <<JSIncludes-Tangle>>
      <<FragmentShader>>
      <<VertexShader>>

      <<WebGL-Advanced-Emitter-Snow>>
    </head>
    <body onload="webGLStart();">
      <<Canvas>>
      <<Tangle-Code>>
      <<Tangle-Panel>>
    </body>
  </html>
  
#+end_src

*** Substructure

#+name: WebGL-Advanced-Emitter-Snow
#+begin_src html
  <script type="text/javascript">
    <<WebGL-Matrix-Code>>
    <<WebGL-Canvas-Init>>
    <<WebGL-Shaders-Init>>
    <<WebGL-Buffers-Init>>
    <<WebGL-Textures-Load>>
    <<WebGL-Texture-Init-Advanced-Emitter>>

    <<ColorUtils>>

    <<AdvancedParticleObject>>

    //FIXME!
    <<Utils>>
    <<AdvancedEmitterObject>>

    <<WebGL-World-Init-Advanced-Emitter-Snow>>
    <<WebGL-Init-Advanced-Emitter>>
    <<Update-World-Advanced-Emitter-Demos>>
    <<WebGL-DrawScene-Advanced-Emitter-Demos>>
    <<WebGL-Animate-VariableStep>>
    <<WebGL-Tick-Advanced-Emitter>>
  </script>
#+end_src

#+name: WebGL-World-Init-Advanced-Emitter-Snow
#+begin_src javascript
  var testEmitter;
  var testEmitter2;
  
  function randomizeWindDirection() {
      (function(val) {
          testEmitter.computeForces = function(particle) {
              return vec3.create([val, 0, 0])
          };
          setTimeout(randomizeWindDirection, 1500);
      })((Math.random() - 0.5)/2);
  }
  
  function initWorld() {
      testEmitter = new Emitter();
      testEmitter.pos = vec3.create([0, 4, -8]);
      testEmitter.startSize = 0.5;
      testEmitter.endSize = 0.5;
      testEmitter.setTexture("data/snowflake.png");
      testEmitter.startColor = { r : 1, g : 1, b : 1, a : 1};
      testEmitter.endColor = { r : 1, g : 1, b : 1, a : 1};
  
      testEmitter.cooldown = 0.3;
      testEmitter.particlesPerFrame = 2;
      testEmitter.startEnergy = 30;
  
      testEmitter.getParticleStartVelocity = function() { return vec3.create([Math.random()/2 - 0.25, -1, 0]); };
      testEmitter.getParticleStartRotation = function() { return Math.random() * 360; };
  
      testEmitter.getParticleStartPosition = function() { return vec3.create([this.pos[0]  + (Math.random() * 10 - 5), this.pos[1], this.pos[2]]); };
  
      randomizeWindDirection();
  }
#+end_src


* Dodatkowe materiały
  Warto sprawdzić poniższe linki za dodatkowymi materiałami n/t systemów cząsteczkowych.
  - http://nehe.gamedev.net/tutorial/particle_engine_using_triangle_strips/21001/
  - http://webgl-tuts.webninja.eu/#tutorials-tutorial9
  - http://learningwebgl.com/blog/?p=1008


* Unassigned code
#+name: JSIncludes
#+begin_src html
  <script type="text/javascript" src="js/gl-matrix-min.js"></script>
  <script type="text/javascript" src="js/webgl-utils.js"></script>
#+end_src

#+name: Canvas
#+begin_src html
  <canvas id="webgl_canvas" style="border: none;" width="640" height="480"></canvas>
#+end_src



#+name: WebGL-Canvas-Init
#+begin_src javascript
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }
#+end_src

#+name: WebGL-Shaders-Init
#+begin_src javascript
 
    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }
 
        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }
 
        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }
 
        gl.shaderSource(shader, str);
        gl.compileShader(shader);
 
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }
 
        return shader;
    }

    var shaderProgram;
 
    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");
 
        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
 
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }
 
        gl.useProgram(shaderProgram);
 
        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
 
        shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
        gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
 
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
        shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
        shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, "uColor");
    }

#+end_src

#+name: WebGL-Matrix-Code
#+begin_src javascript
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();
 
    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }
 
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }
 
 
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }

#+end_src

#+name: WebGL-Textures-Load
#+begin_src javascript
    function handleLoadedTexture(texture) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
 
        gl.bindTexture(gl.TEXTURE_2D, null);
    }

#+end_src


#+name: WebGL-Buffers-Init
#+begin_src javascript
    var particleVertexPositionBuffer;
    var particleVertexTextureCoordBuffer;
 
    function initBuffers() {
        particleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexPositionBuffer);
        vertices = [
            -1.0, -1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0,  1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        particleVertexPositionBuffer.itemSize = 3;
        particleVertexPositionBuffer.numItems = 4;
 
        particleVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, particleVertexTextureCoordBuffer);
        var textureCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        particleVertexTextureCoordBuffer.itemSize = 2;
        particleVertexTextureCoordBuffer.numItems = 4;
    }
 
#+end_src

#+name: WebGL-Animate-VariableStep
#+begin_src javascript
  var lastTime = 0;
  var dtAccum = 0;
  var updateCooldown = 1/30.0; //30FPS
   
  function animate() {
      var timeNow = new Date().getTime();
      if (lastTime != 0) {
          var elapsed = (timeNow - lastTime)/1000.0;
          dtAccum += elapsed;
          if(dtAccum > 1.0) {
              dtAccum = 1.0;
          }
          while(dtAccum > updateCooldown) {
              UpdateWorld(updateCooldown);
              dtAccum -= updateCooldown;
          }
      }
      lastTime = timeNow;
   
  }
  
#+end_src


   
* TO DO
** DONE Empty canvas
** DONE Particle code + display
*** TODO Press a button/link to change particle color ;).
** DONE Particle emitter code + display
   - demo a simple (magic) explosion
** TODO Improved emitter (physics) + display
   - demo snow
     - randomizowana pozycja startowa
     - siły wiatru + grawitacja, wiatr się zmienia co losowy czas
     - kolor stały
   - demo smoke
     - kolor od białego/szarego do czarnego, z przesunięciem środka w lewo
     - grawitacja + wypór = siła zależna od wysokości ;)
     - vel startowy mocno w lewo :)
   - demo jet
     - vel mocno w jakąś stronę
     - orange-white colors
** TODO Bonus
   - particles that follow path
   - demo <3 :).
